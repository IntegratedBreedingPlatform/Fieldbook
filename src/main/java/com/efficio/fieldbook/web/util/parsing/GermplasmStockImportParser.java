package com.efficio.fieldbook.web.util.parsing;

import com.efficio.fieldbook.util.parsing.AbstractExcelFileParser;
import com.efficio.fieldbook.util.parsing.DescriptionSheetParser;
import com.efficio.fieldbook.util.parsing.ImportedDescriptionDetails;
import com.efficio.fieldbook.util.parsing.WorkbookRowConverter;
import com.efficio.fieldbook.util.parsing.validation.NonEmptyValidator;
import com.efficio.fieldbook.util.parsing.validation.ParseValidationMap;
import com.efficio.fieldbook.util.parsing.validation.ValueTypeValidator;
import com.efficio.fieldbook.web.common.exception.FileParsingException;
import com.efficio.fieldbook.web.nursery.bean.ImportedFactor;
import com.efficio.fieldbook.web.nursery.bean.ImportedInventoryList;
import com.efficio.fieldbook.web.nursery.bean.ImportedVariate;
import org.apache.commons.lang3.tuple.ImmutablePair;
import org.apache.commons.lang3.tuple.Pair;
import org.apache.poi.ss.usermodel.Workbook;
import org.generationcp.commons.spring.util.ContextUtil;
import org.generationcp.middleware.domain.inventory.InventoryDetails;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import javax.annotation.Resource;
import java.text.ParseException;
import java.util.*;

/**
 * Created by cyrus on 4/24/15.
 */
public class GermplasmStockImportParser extends AbstractExcelFileParser<Pair<ImportedDescriptionDetails,ImportedInventoryList>> {
	private static final Logger LOG = LoggerFactory.getLogger(InventoryImportParser.class);

	public static final String ALL_LOCATION_VALUES_REQUIRED = "inventory.import.parsing.validation.error.blank.location.value";
	public static final String INVALID_HEADERS = "common.parsing.invalid.headers";
	public static final String NO_REFERENCES_ERROR_DESC = "study.import.inventory.error.no.references";


	protected enum HeaderLabels {
		ENTRY("ENTRY"),
		DESIGNATION("DESIGNATION"),
		GID("GID"),
		CROSS("CROSS"),
		SOURCE("SOURCE"),
		ENTRY_CODE("ENTRY CODE"),
		STOCKID("STOCKID"),
		SEED_QUANTITY("SEED_QUANTITY");

		private String label;

		HeaderLabels(String label) {
			this.label = label;
		}

		public String getLabel() {
			return label;
		}

		public static String[] names() {
			HeaderLabels[] values = values();
			String[] names = new String[values.length];

			for (int i = 0; i < values.length; i++) {
				names[i] = values[i].name();
			}

			return names;
		}
	}

	protected static final int OBSERVATION_SHEET_NO = 1;
	private int currentParseIndex = 0;

	private DescriptionSheetParser<ImportedDescriptionDetails> descriptionSheetParser;

	private Map<String, Integer> observationColumnMap = new HashMap<>();
	private ImportedDescriptionDetails descriptionDetails;
	private ImportedInventoryList importedInventoryList;

	@Resource
	private ContextUtil contextUtil;

	@Override
	public Pair<ImportedDescriptionDetails,ImportedInventoryList> parseWorkbook(Workbook workbook)
			throws FileParsingException {
		this.workbook = workbook;
		try {
			descriptionDetails = new ImportedDescriptionDetails();

			// TODO, set descriptorSheetParser flags to specify parsing conditions without overriding the methods
			descriptionSheetParser = new DescriptionSheetParser<ImportedDescriptionDetails>(descriptionDetails,workbook) {
				@Override
				public void parseDescriptionSheet()
						throws FileParsingException, ParseException {
					this.parseListDetails();
					this.parseConditions();
					this.parseFactors();
					this.parseVariate();
				}
			};
			descriptionSheetParser.parseDescriptionSheet();

			importedInventoryList = new ImportedInventoryList(descriptionDetails.getFilename());

			parseObservationSheet(contextUtil.getCurrentProgramUUID());
		} catch (ParseException e) {
			LOG.debug(e.getMessage(), e);
			throw new FileParsingException(messageSource.getMessage(FILE_INVALID, new Object[]{}, Locale
					.getDefault()));
		}

		// Todo, extend importedInventoryList with descriptionDetails
		return new ImmutablePair<>(descriptionDetails,importedInventoryList);
	}

	/**
	 * Overide this for the autogenerated seed inventory
	 * @param currentProgramUUID
	 * @throws FileParsingException
	 */
	protected void parseObservationSheet(String currentProgramUUID) throws FileParsingException {
		// validate obs header, this will also fillup the observation column map
		if (isObservationsHeaderInvalid()) {
			throw new FileParsingException("Invalid Observation headers");
		}

		currentParseIndex = 1;

		// setup validation for the stock inventory
		ParseValidationMap parseValidationMap = inventoryValidatorWithRequiredStockId();
		InventoryWithStockIdConverter inventoryWithStockIdConverter = new InventoryWithStockIdConverter(workbook,currentParseIndex,
				OBSERVATION_SHEET_NO,descriptionDetails.sizeOfObservationHeader(),HeaderLabels.names(),observationColumnMap);
		inventoryWithStockIdConverter.setValidationMap(parseValidationMap);

		List<InventoryDetails> detailsList = inventoryWithStockIdConverter.convertWorkbookRowsToObject(
				new WorkbookRowConverter.ContinueTillBlank());

		importedInventoryList.setImportedInventoryDetails(detailsList);

	}

	protected ParseValidationMap inventoryValidatorWithRequiredStockId() {
		ParseValidationMap validationMap = new ParseValidationMap();

		// validation for ENTRY column
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.ENTRY.getLabel()), new ValueTypeValidator(Integer.class));
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.ENTRY.getLabel()), new NonEmptyValidator());

		validationMap.addValidation(observationColumnMap.get(HeaderLabels.DESIGNATION.getLabel()), new NonEmptyValidator());

		validationMap.addValidation(observationColumnMap.get(HeaderLabels.GID.getLabel()),
				new ValueTypeValidator(Integer.class));
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.GID.getLabel()), new NonEmptyValidator());

		validationMap.addValidation(observationColumnMap.get(HeaderLabels.CROSS.getLabel()), new NonEmptyValidator());
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.SOURCE.getLabel()), new NonEmptyValidator());
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.STOCKID.getLabel()), new NonEmptyValidator());
		validationMap.addValidation(observationColumnMap.get(HeaderLabels.SEED_QUANTITY.getLabel()), new ValueTypeValidator(Double.class));

		return validationMap;
	}


	protected boolean isObservationsHeaderInvalid() {
		final List<ImportedFactor> importedFactors = new ArrayList<ImportedFactor>() {
			@Override
			public boolean contains(Object o) {
				for (ImportedFactor i : this) {
					if (i.getFactor().equalsIgnoreCase(o.toString())) {
						return true;
					}
				}
				return false;
			}
		};

		importedFactors.addAll(descriptionDetails.getImportedFactors());

		final List<ImportedVariate> importedVariates = new ArrayList<ImportedVariate>() {
			@Override
			public boolean contains(Object o) {
				for (ImportedVariate i : this) {
					if (i.getVariate().equalsIgnoreCase(o.toString())) {
						return true;
					}
				}
				return false;
			}
		};

		importedVariates.addAll(descriptionDetails.getImportedVariates());

		final int headerSize = descriptionDetails.sizeOfObservationHeader();

		for (int i = 0; i < headerSize; i++) {
			// search the current header
			String obsHeader = getCellStringValue(OBSERVATION_SHEET_NO, 0, i);

			boolean inFactors = importedFactors.contains(obsHeader);
			boolean inVariates = importedVariates.contains(obsHeader);

			if (!inFactors && !inVariates) {
				return true;
			} else {
				observationColumnMap.put(obsHeader, i);
			}
		}

		return false;
	}

	public class InventoryWithStockIdConverter extends WorkbookRowConverter<InventoryDetails> {

		private Map<String,Integer> observationColumnMap;

		public InventoryWithStockIdConverter(Workbook workbook, int startingIndex,
				int targetSheetIndex,
				int columnCount, String[] columnLabels,
				Map<String,Integer> observationColumnMap) {
			super(workbook, startingIndex, targetSheetIndex, columnCount, columnLabels);
			this.observationColumnMap = observationColumnMap;
		}

		@Override
		public InventoryDetails convertToObject(Map<Integer, String> rowValues)
				throws FileParsingException {
			// TODO: provide feature for mapping of columns to a different column order
			Integer entryId = Integer
					.parseInt(
							rowValues.get(observationColumnMap.get(HeaderLabels.ENTRY.getLabel())));
			String desig = rowValues.get(
					observationColumnMap.get(HeaderLabels.DESIGNATION.getLabel()));
			Integer gid = Integer.parseInt(rowValues.get(observationColumnMap.get(HeaderLabels.GID.getLabel())));
			String cross = rowValues.get(observationColumnMap.get(HeaderLabels.CROSS.getLabel()));
			String source = rowValues.get(observationColumnMap.get(HeaderLabels.SOURCE.getLabel()));
			String entryCode = rowValues.get(observationColumnMap.get(
					HeaderLabels.ENTRY_CODE.getLabel()));
			String stockId = rowValues.get(observationColumnMap.get(
					HeaderLabels.STOCKID.getLabel()));
			Double seedQuantity = Double.parseDouble(rowValues.get(observationColumnMap.get(
					HeaderLabels.SEED_QUANTITY.getLabel())));

			return new InventoryDetails(entryId,desig,gid,cross,source,entryCode,stockId,seedQuantity);
		}
	}
}
